# 模块功能设计
底层通信模块不会对数据进行修改，但是可能会改变数据的设备状态。
在这个模块中，并没有针对king或者queen实现任何算法层面的区别对待。
我们指定king和queen，仅仅是为了统一建立Progress Group的Rank秩序。
我们之所以这么设计，是为了保证这个模块尽可能保持高度的灵活，以便于实现各种不同的通讯行为。

## federated.py
对上层直接开放的函数接口。
在这个模块中，我们仍然不对king和queen关于他们在联邦学习中扮演的真正作用进行区分。
仅仅只是使用king(rank=0)和queen(rank=1)建立统一的ProcessGroup，并且实现通讯处理。

1. 安全的创建连接。客户端创建失败，抛出异常。服务器端创建失败，输出警告。-->添加客户端
2. 安全的删除连接。--> 删除客户端。
3. 如果有需要，派生一个进程，动态的增加、删除客户端。
4. 保证数据的正确传递。
   1. 对模型数据和字典数据进行合适的处理。
   2. 能够正确记录当前通信的对象，确保对上层透明。该对象，只能由本层进行修改！其余任何地方，可以查看该参数，但是不允许做出修改。
5. 能够提供有效的遍历方案，确保所有的联邦学习的对象，都能够被遍历到。
6. 如果一个fedworld的size大于2，但是，不存在任何sub group的话，清除这个fedworld。（即每次删除操作，都要check以下是不是属于一个group下的sub group，如果是，则要进一步确认是否需要删除这个group）
   1. size>2的fed world我们是通过创建point2point的sub group保证连接的。
   2. 如果不存在任何sub group，则说明所有的客户端都退出了。那这个连接就无效了。
   3. 另外！不要尝试去check这种情况下global的store，因为里面不包含任何openfed相关的状态量。
7. federated模块不提供任何关于客户端状态的逻辑处理代码。
8. 提供了动态接入的功能。（由一个子线程通过对配置文件的扫描实现。）

## register.py
考虑到一个程序可能同时参与了多种联邦学习的场景，在每一个场景中可能扮演着不同的角色，可能是king，也可能是queen。
我们将每一个世界中可能会相互影响的变量，全部定义在world里面，进行统一管理。
而不使用全局变量进行管理！（全局变量均需要共享，会导致不同身份之间相互影响。）
每一次的操作，都需要指定的world。
TODO：合并core.federated_c10d.py中的Register到world中进行统一管理。

当我们遍历每一个PG的时候，我们会为每一个PG返回一个元祖[Monitor, Package]。
这两个模块中，换言之，对于每一个queen而言，我们仍然不需要将任何底层的通信细节返回给上层。
而是直接返回封装好的方法。
其中，Monitor提供了及时的通讯支持。而Package则是提供了数据交换的功能。